// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var $$Set = require("bs-platform/lib/js/set.js");
var List = require("bs-platform/lib/js/list.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var compare = Caml_obj.caml_compare;

var KeySet = $$Set.Make(/* module */[/* compare */compare]);

function peekch(param) {
  var i = param[1];
  var str = param[0];
  if (i < str.length) {
    return /* Some */[Caml_string.get(str, i)];
  } else {
    return /* None */0;
  }
}

function popch(param) {
  return /* tuple */[
          param[0],
          param[1] + 1 | 0
        ];
}

function peekn(param, len) {
  var i = param[1];
  var str = param[0];
  if ((i + len | 0) < str.length) {
    return /* Some */[$$String.sub(str, i, len)];
  } else {
    return /* None */0;
  }
}

function skipWhite(param) {
  var str = param[0];
  var len = str.length;
  var _n = param[1];
  while(true) {
    var n = _n;
    if (n >= len) {
      return /* tuple */[
              str,
              n
            ];
    } else if (Caml_string.get(str, n) === /* " " */32) {
      _n = n + 1 | 0;
      continue ;
    } else {
      return /* tuple */[
              str,
              n
            ];
    }
  };
}

function popn(param, len) {
  return /* tuple */[
          param[0],
          param[1] + len | 0
        ];
}

function match_(stream, matchstr) {
  var len = matchstr.length;
  var match = peekn(stream, len);
  if (match) {
    var peek = match[0];
    if (peek === matchstr) {
      return popn(stream, len);
    } else {
      return Pervasives.failwith("Could not match '" + (matchstr + ("', got '" + (peek + "' instead."))));
    }
  } else {
    return Pervasives.failwith("Could not match " + matchstr);
  }
}

function charsRemaining(param) {
  return param[0].length - param[1] | 0;
}

function create(str) {
  return /* tuple */[
          str,
          0
        ];
}

var Stream = /* module */[
  /* empty : [] */0,
  /* peekch */peekch,
  /* popch */popch,
  /* peekn */peekn,
  /* skipWhite */skipWhite,
  /* popn */popn,
  /* match_ */match_,
  /* charsRemaining */charsRemaining,
  /* create */create
];

function read(name) {
  var ic = Pervasives.open_in(name);
  var try_read = function () {
    var exit = 0;
    var x;
    try {
      x = Pervasives.input_line(ic);
      exit = 1;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.end_of_file) {
        return /* None */0;
      } else {
        throw exn;
      }
    }
    if (exit === 1) {
      return /* Some */[x];
    }
    
  };
  var loop = function (_acc) {
    while(true) {
      var acc = _acc;
      var match = try_read(/* () */0);
      if (match) {
        _acc = /* :: */[
          $$String.make(1, /* "\n" */10),
          /* :: */[
            match[0],
            acc
          ]
        ];
        continue ;
      } else {
        Pervasives.close_in(ic);
        return List.rev(acc);
      }
    };
  };
  return $$String.concat("", loop(/* [] */0));
}

function append_char(s, c) {
  return s + $$String.make(1, c);
}

function split(str, sep) {
  var _stream = /* tuple */[
    str,
    0
  ];
  var sep$1 = sep;
  var _accstr = "";
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var accstr = _accstr;
    var stream = _stream;
    var match = peekch(stream);
    if (match) {
      var c = match[0];
      if (c === sep$1) {
        _acc = /* :: */[
          accstr,
          acc
        ];
        _accstr = "";
        _stream = popch(stream);
        continue ;
      } else {
        _accstr = append_char(accstr, c);
        _stream = popch(stream);
        continue ;
      }
    } else {
      return List.rev(/* :: */[
                  accstr,
                  acc
                ]);
    }
  };
}

var Constants = 0;

var circularBufferSize = 60000;

var vertexSize = 8;

exports.Constants = Constants;
exports.KeySet = KeySet;
exports.circularBufferSize = circularBufferSize;
exports.vertexSize = vertexSize;
exports.Stream = Stream;
exports.read = read;
exports.append_char = append_char;
exports.split = split;
/* KeySet Not a pure module */
