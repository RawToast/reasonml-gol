// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var RGLConstants = require("Reasongl/src/RGLConstants.js");
var Reasongl_web = require("Reasongl/src/web/reasongl_web.js");
var Reprocessing_Env = require("./Reprocessing_Env.js");
var Reprocessing_Font = require("./Reprocessing_Font.js");
var Reprocessing_Matrix = require("./Reprocessing_Matrix.js");
var Reprocessing_Internal = require("./Reprocessing_Internal.js");
var Reprocessing_Constants = require("./Reprocessing_Constants.js");

function translate(x, y, env) {
  return Reprocessing_Matrix.matmatmul(env[/* matrix */16], Reprocessing_Matrix.createTranslation(x, y));
}

function rotate(theta, env) {
  return Reprocessing_Matrix.matmatmul(env[/* matrix */16], Reprocessing_Matrix.createRotation(theta));
}

function scale(x, y, env) {
  return Reprocessing_Matrix.matmatmul(env[/* matrix */16], Reprocessing_Matrix.createScaling(x, y));
}

function shear(x, y, env) {
  return Reprocessing_Matrix.matmatmul(env[/* matrix */16], Reprocessing_Matrix.createShearing(x, y));
}

function fill(color, env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor */init[/* strokeColor */0],
    /* strokeWeight */init[/* strokeWeight */1],
    /* strokeCap */init[/* strokeCap */2],
    /* fillColor : Some */[color],
    /* tintColor */init[/* tintColor */4],
    /* rectMode */init[/* rectMode */5]
  ];
  return /* () */0;
}

function noFill(env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor */init[/* strokeColor */0],
    /* strokeWeight */init[/* strokeWeight */1],
    /* strokeCap */init[/* strokeCap */2],
    /* fillColor : None */0,
    /* tintColor */init[/* tintColor */4],
    /* rectMode */init[/* rectMode */5]
  ];
  return /* () */0;
}

function tint(color, env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor */init[/* strokeColor */0],
    /* strokeWeight */init[/* strokeWeight */1],
    /* strokeCap */init[/* strokeCap */2],
    /* fillColor */init[/* fillColor */3],
    /* tintColor : Some */[color],
    /* rectMode */init[/* rectMode */5]
  ];
  return /* () */0;
}

function noTint(env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor */init[/* strokeColor */0],
    /* strokeWeight */init[/* strokeWeight */1],
    /* strokeCap */init[/* strokeCap */2],
    /* fillColor */init[/* fillColor */3],
    /* tintColor : None */0,
    /* rectMode */init[/* rectMode */5]
  ];
  return /* () */0;
}

function stroke(color, env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor : Some */[color],
    /* strokeWeight */init[/* strokeWeight */1],
    /* strokeCap */init[/* strokeCap */2],
    /* fillColor */init[/* fillColor */3],
    /* tintColor */init[/* tintColor */4],
    /* rectMode */init[/* rectMode */5]
  ];
  return /* () */0;
}

function noStroke(env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor : None */0,
    /* strokeWeight */init[/* strokeWeight */1],
    /* strokeCap */init[/* strokeCap */2],
    /* fillColor */init[/* fillColor */3],
    /* tintColor */init[/* tintColor */4],
    /* rectMode */init[/* rectMode */5]
  ];
  return /* () */0;
}

function strokeWeight(weight, env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor */init[/* strokeColor */0],
    /* strokeWeight */weight,
    /* strokeCap */init[/* strokeCap */2],
    /* fillColor */init[/* fillColor */3],
    /* tintColor */init[/* tintColor */4],
    /* rectMode */init[/* rectMode */5]
  ];
  return /* () */0;
}

function strokeCap(cap, env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor */init[/* strokeColor */0],
    /* strokeWeight */init[/* strokeWeight */1],
    /* strokeCap */cap,
    /* fillColor */init[/* fillColor */3],
    /* tintColor */init[/* tintColor */4],
    /* rectMode */init[/* rectMode */5]
  ];
  return /* () */0;
}

function rectMode(rm, env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor */init[/* strokeColor */0],
    /* strokeWeight */init[/* strokeWeight */1],
    /* strokeCap */init[/* strokeCap */2],
    /* fillColor */init[/* fillColor */3],
    /* tintColor */init[/* tintColor */4],
    /* rectMode */rm
  ];
  return /* () */0;
}

function pushStyle(env) {
  env[/* styleStack */14] = /* :: */[
    env[/* style */13],
    env[/* styleStack */14]
  ];
  return /* () */0;
}

function popStyle(env) {
  var match = env[/* styleStack */14];
  if (match) {
    env[/* style */13] = match[0];
    env[/* styleStack */14] = match[1];
    return /* () */0;
  } else {
    return Pervasives.failwith("Too many `popStyle` without enough `pushStyle`.");
  }
}

function pushMatrix(env) {
  var copy = Reprocessing_Matrix.createIdentity(/* () */0);
  Reprocessing_Matrix.copyInto(env[/* matrix */16], copy);
  env[/* matrixStack */17] = /* :: */[
    copy,
    env[/* matrixStack */17]
  ];
  return /* () */0;
}

function popMatrix(env) {
  var match = env[/* matrixStack */17];
  if (match) {
    env[/* matrix */16] = match[0];
    env[/* matrixStack */17] = match[1];
    return /* () */0;
  } else {
    return Pervasives.failwith("Too many `popMatrix` without enough `pushMatrix`.");
  }
}

function loadImage(filename, $staropt$star, env) {
  var isPixel = $staropt$star ? $staropt$star[0] : false;
  return Reprocessing_Internal.loadImage(env, filename, isPixel);
}

function subImage(img, param, width, height, param$1, subw, subh, env) {
  var match = img[/* glData */0];
  if (match) {
    return Reprocessing_Internal.drawImageWithMatrix(match[0], param[0], param[1], width, height, param$1[0], param$1[1], subw, subh, env);
  } else {
    console.log("image not ready yet, just doing nothing :D");
    return /* () */0;
  }
}

function subImagef(img, param, width, height, param$1, subw, subh, env) {
  var match = img[/* glData */0];
  if (match) {
    return Reprocessing_Internal.drawImageWithMatrixf(match[0], param[0], param[1], width, height, param$1[0], param$1[1], subw, subh, env);
  } else {
    console.log("image not ready yet, just doing nothing :D");
    return /* () */0;
  }
}

function image(img, param, width, height, env) {
  var match = img[/* glData */0];
  if (match) {
    var img$1 = match[0];
    var imgw = img$1[/* width */3];
    var imgh = img$1[/* height */2];
    var exit = 0;
    var w;
    var h;
    if (width) {
      var w$1 = width[0];
      w = w$1;
      if (height) {
        h = height[0];
        exit = 1;
      } else {
        h = imgh;
        exit = 1;
      }
    } else {
      w = imgw;
      if (height) {
        h = height[0];
        exit = 1;
      } else {
        h = imgh;
        exit = 1;
      }
    }
    if (exit === 1) {
      return Reprocessing_Internal.drawImageWithMatrix(img$1, param[0], param[1], w, h, 0, 0, imgw, imgh, env);
    }
    
  } else {
    console.log("image not ready yet, just doing nothing :D");
    return /* () */0;
  }
}

function linef(p1, p2, env) {
  var match = env[/* style */13][/* strokeColor */0];
  if (match) {
    var color = match[0];
    var width = env[/* style */13][/* strokeWeight */1];
    var radius = width / 2;
    var project = env[/* style */13][/* strokeCap */2] === /* Project */2;
    Reprocessing_Internal.drawLineWithMatrix(p1, p2, env[/* matrix */16], color, width, project, env);
    if (env[/* style */13][/* strokeCap */2] === /* Round */0) {
      Reprocessing_Internal.drawEllipse(env, p1, radius, radius, env[/* matrix */16], color);
      return Reprocessing_Internal.drawEllipse(env, p2, radius, radius, env[/* matrix */16], color);
    } else {
      return 0;
    }
  } else {
    return /* () */0;
  }
}

function line(param, param$1, env) {
  return linef(/* tuple */[
              param[0],
              param[1]
            ], /* tuple */[
              param$1[0],
              param$1[1]
            ], env);
}

function ellipsef(center, radx, rady, env) {
  var match = env[/* style */13][/* fillColor */3];
  if (match) {
    Reprocessing_Internal.drawEllipse(env, center, radx, rady, env[/* matrix */16], match[0]);
  }
  var match$1 = env[/* style */13][/* strokeColor */0];
  if (match$1) {
    return Reprocessing_Internal.drawArcStroke(env, center, radx, rady, 0, Reprocessing_Constants.tau, true, false, env[/* matrix */16], match$1[0], env[/* style */13][/* strokeWeight */1]);
  } else {
    return /* () */0;
  }
}

function ellipse(param, radx, rady, env) {
  return ellipsef(/* tuple */[
              param[0],
              param[1]
            ], radx, rady, env);
}

function quadf(p1, p2, p3, p4, env) {
  var partial_arg = env[/* matrix */16];
  var transform = function (param) {
    return Reprocessing_Matrix.matptmul(partial_arg, param);
  };
  var tp1 = Curry._1(transform, p1);
  var tp2 = Curry._1(transform, p2);
  var tp3 = Curry._1(transform, p3);
  var tp4 = Curry._1(transform, p4);
  var match = env[/* style */13][/* fillColor */3];
  if (match) {
    Reprocessing_Internal.addRectToGlobalBatch(env, tp3, tp4, tp2, tp1, match[0]);
  }
  var match$1 = env[/* style */13][/* strokeColor */0];
  if (match$1) {
    var color = match$1[0];
    var width = env[/* style */13][/* strokeWeight */1];
    var matrix = env[/* matrix */16];
    Reprocessing_Internal.drawLineWithMatrix(p1, p2, matrix, color, width, false, env);
    Reprocessing_Internal.drawLineWithMatrix(p2, p3, matrix, color, width, false, env);
    Reprocessing_Internal.drawLineWithMatrix(p3, p4, matrix, color, width, false, env);
    Reprocessing_Internal.drawLineWithMatrix(p1, p4, matrix, color, width, false, env);
    var r = width / 2;
    Reprocessing_Internal.drawEllipse(env, tp1, r, r, Reprocessing_Matrix.identity, color);
    Reprocessing_Internal.drawEllipse(env, tp2, r, r, Reprocessing_Matrix.identity, color);
    Reprocessing_Internal.drawEllipse(env, tp3, r, r, Reprocessing_Matrix.identity, color);
    return Reprocessing_Internal.drawEllipse(env, tp4, r, r, Reprocessing_Matrix.identity, color);
  } else {
    return /* () */0;
  }
}

function quad(param, param$1, param$2, param$3, env) {
  return quadf(/* tuple */[
              param[0],
              param[1]
            ], /* tuple */[
              param$1[0],
              param$1[1]
            ], /* tuple */[
              param$2[0],
              param$2[1]
            ], /* tuple */[
              param$3[0],
              param$3[1]
            ], env);
}

function rectf(param, width, height, env) {
  var y = param[1];
  var x = param[0];
  var match = env[/* style */13][/* rectMode */5];
  switch (match) {
    case 0 : 
        return quadf(/* tuple */[
                    x,
                    y
                  ], /* tuple */[
                    x + width,
                    y
                  ], /* tuple */[
                    x + width,
                    y + height
                  ], /* tuple */[
                    x,
                    y + height
                  ], env);
    case 1 : 
        var x$1 = x - width / 2;
        var y$1 = y - height / 2;
        return quadf(/* tuple */[
                    x$1,
                    y$1
                  ], /* tuple */[
                    x$1 + width,
                    y$1
                  ], /* tuple */[
                    x$1 + width,
                    y$1 + height
                  ], /* tuple */[
                    x$1,
                    y$1 + height
                  ], env);
    case 2 : 
        var x$2 = x - width;
        var y$2 = y - height;
        var width$1 = width * 2;
        var height$1 = height * 2;
        return quadf(/* tuple */[
                    x$2,
                    y$2
                  ], /* tuple */[
                    x$2 + width$1,
                    y$2
                  ], /* tuple */[
                    x$2 + width$1,
                    y$2 + height$1
                  ], /* tuple */[
                    x$2,
                    y$2 + height$1
                  ], env);
    
  }
}

function rect(param, width, height, env) {
  return rectf(/* tuple */[
              param[0],
              param[1]
            ], width, height, env);
}

function bezierPoint(param, param$1, param$2, param$3, t) {
  return /* tuple */[
          Math.pow(1 - t, 3) * param[0] + 3 * Math.pow(1 - t, 2) * t * param$1[0] + 3 * (1 - t) * Math.pow(t, 2) * param$2[0] + Math.pow(t, 3) * param$3[0],
          Math.pow(1 - t, 3) * param[1] + 3 * Math.pow(1 - t, 2) * t * param$1[1] + 3 * (1 - t) * Math.pow(t, 2) * param$2[1] + Math.pow(t, 3) * param$3[1]
        ];
}

function bezierTangent(param, param$1, param$2, param$3, t) {
  var yy3 = param$2[1];
  var xx3 = param$2[0];
  var yy2 = param$1[1];
  var xx2 = param$1[0];
  return /* tuple */[
          -3 * Math.pow(1 - t, 2) * param[0] + 3 * Math.pow(1 - t, 2) * xx2 - 6 * t * (1 - t) * xx2 - 3 * Math.pow(t, 2) * xx3 + 6 * t * (1 - t) * xx3 + 3 * Math.pow(t, 2) * param$3[0],
          -3 * Math.pow(1 - t, 2) * param[1] + 3 * Math.pow(1 - t, 2) * yy2 - 6 * t * (1 - t) * yy2 - 3 * Math.pow(t, 2) * yy3 + 6 * t * (1 - t) * yy3 + 3 * Math.pow(t, 2) * param$3[1]
        ];
}

function bezier(param, param$1, param$2, param$3, env) {
  var yy4 = param$3[1];
  var xx4 = param$3[0];
  var yy3 = param$2[1];
  var xx3 = param$2[0];
  var yy2 = param$1[1];
  var xx2 = param$1[0];
  var yy1 = param[1];
  var xx1 = param[0];
  for(var i = 0; i <= 19; ++i){
    var match = bezierPoint(/* tuple */[
          xx1,
          yy1
        ], /* tuple */[
          xx2,
          yy2
        ], /* tuple */[
          xx3,
          yy3
        ], /* tuple */[
          xx4,
          yy4
        ], i / 20.0);
    var y1 = match[1];
    var x1 = match[0];
    var match$1 = bezierPoint(/* tuple */[
          xx1,
          yy1
        ], /* tuple */[
          xx2,
          yy2
        ], /* tuple */[
          xx3,
          yy3
        ], /* tuple */[
          xx4,
          yy4
        ], (i + 1 | 0) / 20.0);
    var y2 = match$1[1];
    var x2 = match$1[0];
    var match$2 = bezierTangent(/* tuple */[
          xx1,
          yy1
        ], /* tuple */[
          xx2,
          yy2
        ], /* tuple */[
          xx3,
          yy3
        ], /* tuple */[
          xx4,
          yy4
        ], i / 20.0);
    var match$3 = bezierTangent(/* tuple */[
          xx1,
          yy1
        ], /* tuple */[
          xx2,
          yy2
        ], /* tuple */[
          xx3,
          yy3
        ], /* tuple */[
          xx4,
          yy4
        ], (i + 1 | 0) / 20.0);
    var a1 = Math.atan2(match$2[1], match$2[0]) - Reprocessing_Constants.half_pi;
    var a2 = Math.atan2(match$3[1], match$3[0]) - Reprocessing_Constants.half_pi;
    var strokeWeightf = env[/* style */13][/* strokeWeight */1];
    quadf(/* tuple */[
          x1 + Math.cos(a1) * strokeWeightf / 2,
          y1 + Math.sin(a1) * strokeWeightf / 2
        ], /* tuple */[
          x1 - Math.cos(a1) * strokeWeightf / 2,
          y1 - Math.sin(a1) * strokeWeightf / 2
        ], /* tuple */[
          x2 - Math.cos(a2) * strokeWeightf / 2,
          y2 - Math.sin(a2) * strokeWeightf / 2
        ], /* tuple */[
          x2 + Math.cos(a2) * strokeWeightf / 2,
          y2 + Math.sin(a2) * strokeWeightf / 2
        ], env);
  }
  return /* () */0;
}

function curvePoint(param, param$1, param$2, param$3, t) {
  var yy3 = param$2[1];
  var xx3 = param$2[0];
  var yy2 = param$1[1];
  var xx2 = param$1[0];
  var mx0 = (1 - 0.5) * (xx3 - param[0]);
  var my0 = (1 - 0.5) * (yy3 - param[1]);
  var mx1 = (1 - 0.5) * (param$3[0] - xx2);
  var my1 = (1 - 0.5) * (param$3[1] - yy2);
  return /* tuple */[
          (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * xx2 + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * mx0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * xx3 + (Math.pow(t, 3) - Math.pow(t, 2)) * mx1,
          (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * yy2 + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * my0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * yy3 + (Math.pow(t, 3) - Math.pow(t, 2)) * my1
        ];
}

function curveTangent(param, param$1, param$2, param$3, t) {
  var yy3 = param$2[1];
  var xx3 = param$2[0];
  var yy2 = param$1[1];
  var xx2 = param$1[0];
  var mx0 = (1 - 0.5) * (xx3 - param[0]);
  var my0 = (1 - 0.5) * (yy3 - param[1]);
  var mx1 = (1 - 0.5) * (param$3[0] - xx2);
  var my1 = (1 - 0.5) * (param$3[1] - yy2);
  return /* tuple */[
          (6 * Math.pow(t, 2) - 6 * t) * xx2 + (3 * Math.pow(t, 2) - 4 * t + 1) * mx0 + (-6 * Math.pow(t, 2) + 6 * t) * xx3 + (3 * Math.pow(t, 2) - 2 * t) * mx1,
          (6 * Math.pow(t, 2) - 6 * t) * yy2 + (3 * Math.pow(t, 2) - 4 * t + 1) * my0 + (-6 * Math.pow(t, 2) + 6 * t) * yy3 + (3 * Math.pow(t, 2) - 2 * t) * my1
        ];
}

function curve(param, param$1, param$2, param$3, env) {
  var yy4 = param$3[1];
  var xx4 = param$3[0];
  var yy3 = param$2[1];
  var xx3 = param$2[0];
  var yy2 = param$1[1];
  var xx2 = param$1[0];
  var yy1 = param[1];
  var xx1 = param[0];
  for(var i = 0; i <= 19; ++i){
    var match = curvePoint(/* tuple */[
          xx1,
          yy1
        ], /* tuple */[
          xx2,
          yy2
        ], /* tuple */[
          xx3,
          yy3
        ], /* tuple */[
          xx4,
          yy4
        ], i / 20.0);
    var y1 = match[1];
    var x1 = match[0];
    var match$1 = curvePoint(/* tuple */[
          xx1,
          yy1
        ], /* tuple */[
          xx2,
          yy2
        ], /* tuple */[
          xx3,
          yy3
        ], /* tuple */[
          xx4,
          yy4
        ], (i + 1 | 0) / 20.0);
    var y2 = match$1[1];
    var x2 = match$1[0];
    var match$2 = curveTangent(/* tuple */[
          xx1,
          yy1
        ], /* tuple */[
          xx2,
          yy2
        ], /* tuple */[
          xx3,
          yy3
        ], /* tuple */[
          xx4,
          yy4
        ], i / 20.0);
    var match$3 = curveTangent(/* tuple */[
          xx1,
          yy1
        ], /* tuple */[
          xx2,
          yy2
        ], /* tuple */[
          xx3,
          yy3
        ], /* tuple */[
          xx4,
          yy4
        ], (i + 1 | 0) / 20.0);
    var a1 = Math.atan2(match$2[1], match$2[0]) - Reprocessing_Constants.half_pi;
    var a2 = Math.atan2(match$3[1], match$3[0]) - Reprocessing_Constants.half_pi;
    var strokeWeightf = env[/* style */13][/* strokeWeight */1];
    quadf(/* tuple */[
          x1 + Math.cos(a1) * strokeWeightf / 2,
          y1 + Math.sin(a1) * strokeWeightf / 2
        ], /* tuple */[
          x1 - Math.cos(a1) * strokeWeightf / 2,
          y1 - Math.sin(a1) * strokeWeightf / 2
        ], /* tuple */[
          x2 - Math.cos(a2) * strokeWeightf / 2,
          y2 - Math.sin(a2) * strokeWeightf / 2
        ], /* tuple */[
          x2 + Math.cos(a2) * strokeWeightf / 2,
          y2 + Math.sin(a2) * strokeWeightf / 2
        ], env);
  }
  return /* () */0;
}

function pixelf(param, color, env) {
  var y = param[1];
  var x = param[0];
  var w = env[/* style */13][/* strokeWeight */1];
  return Reprocessing_Internal.addRectToGlobalBatch(env, /* tuple */[
              x + w,
              y + w
            ], /* tuple */[
              x,
              y + w
            ], /* tuple */[
              x + w,
              y
            ], /* tuple */[
              x,
              y
            ], color);
}

function pixel(param, color, env) {
  return pixelf(/* tuple */[
              param[0],
              param[1]
            ], color, env);
}

function trianglef(p1, p2, p3, env) {
  var partial_arg = env[/* matrix */16];
  var transform = function (param) {
    return Reprocessing_Matrix.matptmul(partial_arg, param);
  };
  var tp1 = Curry._1(transform, p1);
  var tp2 = Curry._1(transform, p2);
  var tp3 = Curry._1(transform, p3);
  var match = env[/* style */13][/* fillColor */3];
  if (match) {
    Reprocessing_Internal.drawTriangle(env, tp1, tp2, tp3, match[0]);
  }
  var match$1 = env[/* style */13][/* strokeColor */0];
  if (match$1) {
    var color = match$1[0];
    var width = env[/* style */13][/* strokeWeight */1];
    var matrix = env[/* matrix */16];
    Reprocessing_Internal.drawLineWithMatrix(p1, p2, matrix, color, width, false, env);
    Reprocessing_Internal.drawLineWithMatrix(p2, p3, matrix, color, width, false, env);
    Reprocessing_Internal.drawLineWithMatrix(p1, p3, matrix, color, width, false, env);
    var r = width / 2;
    Reprocessing_Internal.drawEllipse(env, tp1, r, r, Reprocessing_Matrix.identity, color);
    Reprocessing_Internal.drawEllipse(env, tp2, r, r, Reprocessing_Matrix.identity, color);
    return Reprocessing_Internal.drawEllipse(env, tp3, r, r, Reprocessing_Matrix.identity, color);
  } else {
    return /* () */0;
  }
}

function triangle(param, param$1, param$2, env) {
  return trianglef(/* tuple */[
              param[0],
              param[1]
            ], /* tuple */[
              param$1[0],
              param$1[1]
            ], /* tuple */[
              param$2[0],
              param$2[1]
            ], env);
}

function arcf(center, radx, rady, start, stop, isOpen, isPie, env) {
  var match = env[/* style */13][/* fillColor */3];
  if (match) {
    Reprocessing_Internal.drawArc(env, center, radx, rady, start, stop, isPie, env[/* matrix */16], match[0]);
  }
  var match$1 = env[/* style */13][/* strokeColor */0];
  if (match$1) {
    return Reprocessing_Internal.drawArcStroke(env, center, radx, rady, start, stop, isOpen, isPie, env[/* matrix */16], match$1[0], env[/* style */13][/* strokeWeight */1]);
  } else {
    return /* () */0;
  }
}

function arc(param, radx, rady, start, stop, isOpen, isPie, env) {
  return arcf(/* tuple */[
              param[0],
              param[1]
            ], radx, rady, start, stop, isOpen, isPie, env);
}

function loadFont(filename, $staropt$star, env) {
  var isPixel = $staropt$star ? $staropt$star[0] : false;
  return Reprocessing_Font.Font[/* parseFontFormat */10](env, filename, isPixel);
}

function text(font, body, param, env) {
  return Reprocessing_Font.Font[/* drawString */13](env, font, body, param[0], param[1]);
}

function textWidth(font, body, env) {
  return Reprocessing_Font.Font[/* calcStringWidth */14](env, font, body) | 0;
}

function clear(env) {
  return Curry._2(Reasongl_web.Gl[/* clear */45], env[/* gl */2], RGLConstants.color_buffer_bit | RGLConstants.depth_buffer_bit);
}

function background(color, env) {
  clear(env);
  var w = Reprocessing_Env.width(env);
  var h = Reprocessing_Env.height(env);
  return Reprocessing_Internal.addRectToGlobalBatch(env, /* tuple */[
              w,
              h
            ], /* tuple */[
              0,
              h
            ], /* tuple */[
              w,
              0
            ], /* tuple */[
              0,
              0
            ], color);
}

var createImage = Reprocessing_Internal.createImage;

var withImage = Reprocessing_Internal.drawOnImage;

function isImageDrawnTo(image) {
  return image[/* drawnTo */1];
}

var clearImage = Reprocessing_Internal.clearImage;

exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.shear = shear;
exports.fill = fill;
exports.noFill = noFill;
exports.tint = tint;
exports.noTint = noTint;
exports.stroke = stroke;
exports.noStroke = noStroke;
exports.strokeWeight = strokeWeight;
exports.strokeCap = strokeCap;
exports.rectMode = rectMode;
exports.pushStyle = pushStyle;
exports.popStyle = popStyle;
exports.pushMatrix = pushMatrix;
exports.popMatrix = popMatrix;
exports.loadImage = loadImage;
exports.image = image;
exports.subImage = subImage;
exports.subImagef = subImagef;
exports.rectf = rectf;
exports.rect = rect;
exports.curve = curve;
exports.linef = linef;
exports.line = line;
exports.ellipsef = ellipsef;
exports.ellipse = ellipse;
exports.quadf = quadf;
exports.quad = quad;
exports.pixelf = pixelf;
exports.pixel = pixel;
exports.trianglef = trianglef;
exports.triangle = triangle;
exports.bezier = bezier;
exports.arcf = arcf;
exports.arc = arc;
exports.loadFont = loadFont;
exports.text = text;
exports.textWidth = textWidth;
exports.clear = clear;
exports.background = background;
exports.withImage = withImage;
exports.createImage = createImage;
exports.isImageDrawnTo = isImageDrawnTo;
exports.clearImage = clearImage;
/* Reasongl_web Not a pure module */
