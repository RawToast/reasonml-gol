// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Random = require("bs-platform/lib/js/random.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Reprocessing_Common = require("./Reprocessing_Common.js");
var Reprocessing_Constants = require("./Reprocessing_Constants.js");

var lookup_table = [/* array */[]];

function round(i) {
  return Math.floor(i + 0.5);
}

function sq(x) {
  return Caml_int32.imul(x, x);
}

function pow(base, exp) {
  if (exp !== 0) {
    if (exp !== 1) {
      var b = pow(base, exp / 2 | 0);
      return Caml_int32.imul(Caml_int32.imul(b, b), exp % 2 === 0 ? 1 : base);
    } else {
      return base;
    }
  } else {
    return 1;
  }
}

function constrain(amt, low, high) {
  return Caml_obj.caml_max(Caml_obj.caml_min(amt, high), low);
}

function remapf(value, low1, high1, low2, high2) {
  return low2 + (high2 - low2) * ((value - low1) / (high1 - low1));
}

function remap(value, low1, high1, low2, high2) {
  return remapf(value, low1, high1, low2, high2) | 0;
}

function norm(value, low, high) {
  return remapf(value, low, high, 0, 1);
}

function randomf(min, max) {
  return Random.$$float(max - min) + min;
}

function random(min, max) {
  return Random.$$int(max - min | 0) + min | 0;
}

var randomSeed = Random.init;

function randomGaussian() {
  var u1 = 0.0;
  var u2 = 0.0;
  while(u1 <= Number.MIN_VALUE) {
    u1 = Random.$$float(1.0);
    u2 = Random.$$float(1.0);
  };
  return Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(Reprocessing_Constants.two_pi * u2);
}

function lerpf(low, high) {
  return (function (param) {
      return remapf(param, 0, 1, low, high);
    });
}

function lerp(low, high, value) {
  return lerpf(low, high)(value) | 0;
}

function distf(param, param$1) {
  var dx = param$1[0] - param[0];
  var dy = param$1[1] - param[1];
  return Math.sqrt(dx * dx + dy * dy);
}

function dist(param, param$1) {
  return distf(/* tuple */[
              param[0],
              param[1]
            ], /* tuple */[
              param$1[0],
              param$1[1]
            ]);
}

function magf(vec) {
  return distf(/* tuple */[
              0,
              0
            ], vec);
}

function mag(vec) {
  return dist(/* tuple */[
              0,
              0
            ], vec);
}

function lerpColor(low, high, value) {
  return /* record */[
          /* r */lerpf(low[/* r */0], high[/* r */0])(value),
          /* g */lerpf(low[/* g */1], high[/* g */1])(value),
          /* b */lerpf(low[/* b */2], high[/* b */2])(value),
          /* a */lerpf(low[/* a */3], high[/* a */3])(value)
        ];
}

function degrees(x) {
  return 180.0 / Reprocessing_Constants.pi * x;
}

function radians(x) {
  return Reprocessing_Constants.pi / 180.0 * x;
}

function noise(x, y, z) {
  var p = lookup_table[0];
  var fade = function (t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
  };
  var grad = function (hash, x, y, z) {
    var match = hash & 15;
    if (match > 15 || match < 0) {
      return 0.0;
    } else {
      switch (match) {
        case 0 : 
            return x + y;
        case 1 : 
            return -x + y;
        case 2 : 
            return x - y;
        case 3 : 
            return -x - y;
        case 4 : 
            return x + z;
        case 5 : 
            return -x + z;
        case 6 : 
            return x - z;
        case 7 : 
            return -x - z;
        case 8 : 
            return y + z;
        case 10 : 
            return y - z;
        case 12 : 
            return y + x;
        case 9 : 
        case 13 : 
            return -y + z;
        case 14 : 
            return y - x;
        case 11 : 
        case 15 : 
            return -y - z;
        
      }
    }
  };
  var xi = x & 255;
  var yi = y & 255;
  var zi = z & 255;
  var xf = x - Math.floor(x);
  var yf = y - Math.floor(y);
  var zf = z - Math.floor(z);
  var u = fade(xf);
  var v = fade(yf);
  var w = fade(zf);
  var aaa = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi) + yi | 0) + zi | 0);
  var aba = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi) + (yi + 1 | 0) | 0) + zi | 0);
  var aab = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi) + yi | 0) + (zi + 1 | 0) | 0);
  var abb = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi) + (yi + 1 | 0) | 0) + (zi + 1 | 0) | 0);
  var baa = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi + 1 | 0) + yi | 0) + zi | 0);
  var bba = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi + 1 | 0) + (yi + 1 | 0) | 0) + zi | 0);
  var bab = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi + 1 | 0) + yi | 0) + (zi + 1 | 0) | 0);
  var bbb = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi + 1 | 0) + (yi + 1 | 0) | 0) + (zi + 1 | 0) | 0);
  var x1 = lerpf(grad(aaa, xf, yf, zf), grad(baa, xf - 1.0, yf, zf))(u);
  var x2 = lerpf(grad(aba, xf, yf - 1.0, zf), grad(bba, xf - 1.0, yf - 1.0, zf))(u);
  var y1 = lerpf(x1, x2)(v);
  var x1$1 = lerpf(grad(aab, xf, yf, zf - 1.0), grad(bab, xf - 1.0, yf, zf - 1.0))(u);
  var x2$1 = lerpf(grad(abb, xf, yf - 1.0, zf - 1.0), grad(bbb, xf - 1.0, yf - 1.0, zf - 1.0))(u);
  var y2 = lerpf(x1$1, x2$1)(v);
  return (lerpf(y1, y2)(w) + 1.0) / 2.0;
}

function shuffle(array) {
  var array$1 = $$Array.copy(array);
  var length = array$1.length;
  for(var i = 0; i <= 255; ++i){
    var j = Random.$$int(length - i | 0);
    var tmp = Caml_array.caml_array_get(array$1, i);
    Caml_array.caml_array_set(array$1, i, Caml_array.caml_array_get(array$1, i + j | 0));
    Caml_array.caml_array_set(array$1, i + j | 0, tmp);
  }
  return array$1;
}

function noiseSeed(seed) {
  var state = Random.get_state(/* () */0);
  Random.init(seed);
  var array = Caml_array.caml_make_vect(256, 0);
  var array$1 = $$Array.mapi((function (i, _) {
          return i;
        }), array);
  var array$2 = shuffle(array$1);
  var double_array = $$Array.append(array$2, array$2);
  lookup_table[0] = double_array;
  return Random.set_state(state);
}

function color(r, g, b, a) {
  return /* record */[
          /* r */r / 255,
          /* g */g / 255,
          /* b */b / 255,
          /* a */a / 255
        ];
}

function colorf(r, g, b, a) {
  return /* record */[
          /* r */r,
          /* g */g,
          /* b */b,
          /* a */a
        ];
}

function intersectRectCircle(param, rectW, rectH, param$1, circleRad) {
  var halfW = rectW / 2;
  var halfH = rectH / 2;
  var cdistX = Math.abs(param$1[0] - (param[0] + halfW));
  var cdistY = Math.abs(param$1[1] - (param[1] + halfH));
  if (cdistX > halfW + circleRad || cdistY > halfH + circleRad) {
    return false;
  } else if (cdistX <= halfW || cdistY <= halfH) {
    return true;
  } else {
    var cornerDistSq = Math.pow(cdistX - halfW, 2) + Math.pow(cdistY - halfH, 2);
    return cornerDistSq <= Math.pow(circleRad, 2);
  }
}

function intersectRectRect(param, rect1W, rect1H, param$1, rect2W, rect2H) {
  var ry2 = param$1[1];
  var rx2 = param$1[0];
  var ry1 = param[1];
  var rx1 = param[0];
  return !(rx2 > rx1 + rect1W || rx2 + rect2W < rx1 || ry2 > ry1 + rect1H || ry2 + rect2H < ry1);
}

var split = Reprocessing_Common.split;

exports.color = color;
exports.colorf = colorf;
exports.round = round;
exports.sq = sq;
exports.pow = pow;
exports.constrain = constrain;
exports.remapf = remapf;
exports.remap = remap;
exports.norm = norm;
exports.randomf = randomf;
exports.random = random;
exports.randomSeed = randomSeed;
exports.randomGaussian = randomGaussian;
exports.lerpf = lerpf;
exports.lerp = lerp;
exports.lerpColor = lerpColor;
exports.distf = distf;
exports.dist = dist;
exports.magf = magf;
exports.mag = mag;
exports.degrees = degrees;
exports.radians = radians;
exports.noise = noise;
exports.noiseSeed = noiseSeed;
exports.split = split;
exports.intersectRectCircle = intersectRectCircle;
exports.intersectRectRect = intersectRectRect;
/* Reprocessing_Common Not a pure module */
