// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Reasongl_web = require("Reasongl/src/web/reasongl_web.js");
var Reprocessing_Common = require("./Reprocessing_Common.js");
var Reprocessing_Internal = require("./Reprocessing_Internal.js");
var Reprocessing_DefaultFont = require("./Reprocessing_DefaultFont.js");

function intCompare(i, j) {
  var match = i === j;
  if (match) {
    return 0;
  } else {
    var match$1 = i < j;
    if (match$1) {
      return -1;
    } else {
      return 1;
    }
  }
}

var IntMap = $$Map.Make(/* module */[/* compare */intCompare]);

function compare(param, param$1) {
  var first = intCompare(param[0], param$1[0]);
  if (first !== 0) {
    return first;
  } else {
    return intCompare(param[1], param$1[1]);
  }
}

var IntPairMap = $$Map.Make(/* module */[/* compare */compare]);

var defaultFont = [/* None */0];

function parse_num(_stream, _acc) {
  while(true) {
    var acc = _acc;
    var stream = _stream;
    var match = Reprocessing_Common.Stream[/* peekch */1](stream);
    var exit = 0;
    var c;
    if (match) {
      var c$1 = match[0];
      if (c$1 >= 47) {
        if (c$1 > 57 || c$1 < 48) {
          exit = 1;
        } else {
          c = c$1;
          exit = 2;
        }
      } else if (c$1 >= 45) {
        c = c$1;
        exit = 2;
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    switch (exit) {
      case 1 : 
          try {
            return /* tuple */[
                    stream,
                    Caml_format.caml_float_of_string(acc)
                  ];
          }
          catch (exn){
            return Pervasives.failwith("Could not parse number [" + (acc + "]."));
          }
      case 2 : 
          _acc = Reprocessing_Common.append_char(acc, c);
          _stream = Reprocessing_Common.Stream[/* popch */2](stream);
          continue ;
      
    }
  };
}

function parse_num$1(stream) {
  return parse_num(stream, "");
}

function parse_string(_stream, _acc) {
  while(true) {
    var acc = _acc;
    var stream = _stream;
    var match = Reprocessing_Common.Stream[/* peekch */1](stream);
    if (match) {
      var c = match[0];
      if (c !== 34) {
        _acc = Reprocessing_Common.append_char(acc, c);
        _stream = Reprocessing_Common.Stream[/* popch */2](stream);
        continue ;
      } else {
        return /* tuple */[
                Reprocessing_Common.Stream[/* popch */2](stream),
                acc
              ];
      }
    } else {
      return Pervasives.failwith("Unterminated string.");
    }
  };
}

function parse_string$1(stream) {
  return parse_string(stream, "");
}

function pop_line(_stream) {
  while(true) {
    var stream = _stream;
    var match = Reprocessing_Common.Stream[/* peekch */1](stream);
    if (match) {
      if (match[0] !== 10) {
        _stream = Reprocessing_Common.Stream[/* popch */2](stream);
        continue ;
      } else {
        return Reprocessing_Common.Stream[/* popch */2](stream);
      }
    } else {
      return Pervasives.failwith("could not pop line");
    }
  };
}

function parse_char_fmt(_stream, _num, _map) {
  while(true) {
    var map = _map;
    var num = _num;
    var stream = _stream;
    if (num < 0) {
      return /* tuple */[
              stream,
              map
            ];
    } else if (Caml_obj.caml_notequal(Reprocessing_Common.Stream[/* peekn */3](stream, 4), /* Some */["char"])) {
      Pervasives.prerr_string("Warning: encountered end of char sequence early when loading font.\n");
      return /* tuple */[
              stream,
              map
            ];
    } else {
      var stream$1 = Reprocessing_Common.Stream[/* match_ */6](stream, "char id=");
      var match = parse_num(stream$1, "");
      var stream$2 = Reprocessing_Common.Stream[/* match_ */6](Reprocessing_Common.Stream[/* skipWhite */4](match[0]), "x=");
      var match$1 = parse_num(stream$2, "");
      var stream$3 = Reprocessing_Common.Stream[/* match_ */6](Reprocessing_Common.Stream[/* skipWhite */4](match$1[0]), "y=");
      var match$2 = parse_num(stream$3, "");
      var stream$4 = Reprocessing_Common.Stream[/* match_ */6](Reprocessing_Common.Stream[/* skipWhite */4](match$2[0]), "width=");
      var match$3 = parse_num(stream$4, "");
      var stream$5 = Reprocessing_Common.Stream[/* match_ */6](Reprocessing_Common.Stream[/* skipWhite */4](match$3[0]), "height=");
      var match$4 = parse_num(stream$5, "");
      var stream$6 = Reprocessing_Common.Stream[/* match_ */6](Reprocessing_Common.Stream[/* skipWhite */4](match$4[0]), "xoffset=");
      var match$5 = parse_num(stream$6, "");
      var stream$7 = Reprocessing_Common.Stream[/* match_ */6](Reprocessing_Common.Stream[/* skipWhite */4](match$5[0]), "yoffset=");
      var match$6 = parse_num(stream$7, "");
      var stream$8 = Reprocessing_Common.Stream[/* match_ */6](Reprocessing_Common.Stream[/* skipWhite */4](match$6[0]), "xadvance=");
      var match$7 = parse_num(stream$8, "");
      var stream$9 = pop_line(match$7[0]);
      var new_map = Curry._3(IntMap[/* add */3], match[1] | 0, /* record */[
            /* x */match$1[1],
            /* y */match$2[1],
            /* width */match$3[1],
            /* height */match$4[1],
            /* xoffset */match$5[1],
            /* yoffset */match$6[1],
            /* xadvance */match$7[1]
          ], map);
      _map = new_map;
      _num = num - 1 | 0;
      _stream = stream$9;
      continue ;
    }
  };
}

function parse_kern_fmt(_stream, _num, _map) {
  while(true) {
    var map = _map;
    var num = _num;
    var stream = _stream;
    if (num === 0) {
      return /* tuple */[
              stream,
              map
            ];
    } else {
      var stream$1 = Reprocessing_Common.Stream[/* match_ */6](stream, "kerning first=");
      var match = parse_num(stream$1, "");
      var stream$2 = Reprocessing_Common.Stream[/* match_ */6](Reprocessing_Common.Stream[/* skipWhite */4](match[0]), "second=");
      var match$1 = parse_num(stream$2, "");
      var stream$3 = Reprocessing_Common.Stream[/* match_ */6](Reprocessing_Common.Stream[/* skipWhite */4](match$1[0]), "amount=");
      var match$2 = parse_num(stream$3, "");
      var stream$4 = pop_line(match$2[0]);
      var new_map = Curry._3(IntPairMap[/* add */3], /* tuple */[
            match[1] | 0,
            match$1[1] | 0
          ], match$2[1], map);
      _map = new_map;
      _num = num - 1 | 0;
      _stream = stream$4;
      continue ;
    }
  };
}

function replaceFilename(path, filename) {
  var splitStr = Reprocessing_Common.split(path, /* "/" */47);
  var revLst = List.rev(splitStr);
  var newRevLst = revLst ? /* :: */[
      filename,
      revLst[1]
    ] : /* [] */0;
  var newLst = List.rev(newRevLst);
  return $$String.concat("/", newLst);
}

function getCharMapAndKernMap(str) {
  var stream = Reprocessing_Common.Stream[/* create */8](str + "\n");
  var match = Reprocessing_Common.Stream[/* peekn */3](stream, 9);
  var match$1 = match ? (
      match[0] === "info res=" ? parse_num(Reprocessing_Common.Stream[/* match_ */6](stream, "info res="), "") : /* tuple */[
          stream,
          1
        ]
    ) : /* tuple */[
      stream,
      1
    ];
  var stream$1 = pop_line(match$1[0]);
  var stream$2 = Reprocessing_Common.Stream[/* match_ */6](stream$1, "common lineHeight=");
  var match$2 = parse_num(stream$2, "");
  var stream$3 = pop_line(match$2[0]);
  var stream$4 = Reprocessing_Common.Stream[/* match_ */6](stream$3, "page id=0 file=\"");
  var match$3 = parse_string(stream$4, "");
  var stream$5 = pop_line(match$3[0]);
  var stream$6 = Reprocessing_Common.Stream[/* match_ */6](stream$5, "chars count=");
  var match$4 = parse_num(stream$6, "");
  var stream$7 = pop_line(match$4[0]);
  var match$5 = parse_char_fmt(stream$7, match$4[1] | 0, IntMap[/* empty */0]);
  var stream$8 = Reprocessing_Common.Stream[/* match_ */6](match$5[0], "kernings count=");
  var match$6 = parse_num(stream$8, "");
  var stream$9 = pop_line(match$6[0]);
  var match$7 = parse_kern_fmt(stream$9, match$6[1] | 0, IntPairMap[/* empty */0]);
  return /* tuple */[
          match$5[1],
          match$7[1],
          match$3[1],
          match$1[1],
          match$2[1]
        ];
}

function parseFontFormat(env, path, isPixel) {
  var ret = [/* None */0];
  Curry._2(Reasongl_web.Gl[/* File */1][/* readFile */0], path, (function (str) {
          var match = getCharMapAndKernMap(str);
          var img_filename = replaceFilename(path, match[2]);
          ret[0] = /* Some */[/* record */[
              /* chars */match[0],
              /* kerning */match[1],
              /* res */match[3],
              /* lineHeight */match[4],
              /* image */Reprocessing_Internal.loadImage(env, img_filename, isPixel)
            ]];
          return /* () */0;
        }));
  return ret;
}

function getChar(fnt, ch) {
  try {
    return Curry._2(IntMap[/* find */21], ch, fnt[/* chars */0]);
  }
  catch (exn){
    return Pervasives.failwith("Could not find character " + (String(ch) + " in font."));
  }
}

function drawChar(env, fnt, image, ch, last, x, y) {
  var c = getChar(fnt, ch);
  var kernAmount;
  if (last) {
    try {
      kernAmount = Curry._2(IntPairMap[/* find */21], /* tuple */[
            last[0],
            ch
          ], fnt[/* kerning */1]);
    }
    catch (exn){
      kernAmount = 0;
    }
  } else {
    kernAmount = 0;
  }
  if (image) {
    Reprocessing_Internal.drawImageWithMatrixf(image[0], x + (c[/* xoffset */4] + kernAmount) / fnt[/* res */2], y + c[/* yoffset */5] / fnt[/* res */2], c[/* width */2] / fnt[/* res */2], c[/* height */3] / fnt[/* res */2], c[/* x */0] | 0, c[/* y */1] | 0, c[/* width */2] | 0, c[/* height */3] | 0, env);
    return (c[/* xadvance */6] + kernAmount) / fnt[/* res */2];
  } else {
    return (c[/* xadvance */6] + kernAmount) / fnt[/* res */2];
  }
}

function drawString(env, fnt, str, x, y) {
  var fnt$1 = fnt ? fnt[0] : defaultFont;
  var match = fnt$1[0];
  if (match) {
    var fnt$2 = match[0];
    var match$1 = fnt$2[/* image */4][/* glData */0];
    if (match$1) {
      var img = match$1[0];
      var offset = [x];
      var lastChar = [/* None */0];
      return $$String.iter((function (c) {
                    var advance = drawChar(env, fnt$2, /* Some */[img], c, lastChar[0], offset[0], y);
                    offset[0] += advance;
                    lastChar[0] = /* Some */[c];
                    return /* () */0;
                  }), str);
    } else {
      console.log("loading font.");
      return /* () */0;
    }
  } else {
    return /* () */0;
  }
}

function calcStringWidth(env, fnt, str) {
  var fnt$1 = fnt ? fnt[0] : defaultFont;
  var match = fnt$1[0];
  if (match) {
    var fnt$2 = match[0];
    var offset = [0];
    var lastChar = [/* None */0];
    $$String.iter((function (c) {
            offset[0] += drawChar(env, fnt$2, /* None */0, c, lastChar[0], offset[0], 0);
            lastChar[0] = /* Some */[c];
            return /* () */0;
          }), str);
    return offset[0];
  } else {
    return 0;
  }
}

function loadDefaultFont(env) {
  var match = Reprocessing_DefaultFont.read("font.fnt");
  var data = match ? match[0] : Pervasives.failwith("Failed to load default font. This shouldn't happen.");
  var match$1 = Reprocessing_DefaultFont.read("font.png");
  var imageData = match$1 ? match$1[0] : Pervasives.failwith("Failed to load default font image. This shouldn't happen");
  var match$2 = getCharMapAndKernMap(data);
  defaultFont[0] = /* Some */[/* record */[
      /* chars */match$2[0],
      /* kerning */match$2[1],
      /* res */match$2[3],
      /* lineHeight */match$2[4],
      /* image */Reprocessing_Internal.loadImageFromMemory(env, imageData, false)
    ]];
  return /* () */0;
}

var Font = /* module */[
  /* IntMap */IntMap,
  /* IntPairMap */IntPairMap,
  /* defaultFont */defaultFont,
  /* parse_num */parse_num$1,
  /* parse_string */parse_string$1,
  /* pop_line */pop_line,
  /* parse_char_fmt */parse_char_fmt,
  /* parse_kern_fmt */parse_kern_fmt,
  /* replaceFilename */replaceFilename,
  /* getCharMapAndKernMap */getCharMapAndKernMap,
  /* parseFontFormat */parseFontFormat,
  /* getChar */getChar,
  /* drawChar */drawChar,
  /* drawString */drawString,
  /* calcStringWidth */calcStringWidth,
  /* loadDefaultFont */loadDefaultFont
];

var Internal = 0;

exports.Internal = Internal;
exports.intCompare = intCompare;
exports.Font = Font;
/* IntMap Not a pure module */
