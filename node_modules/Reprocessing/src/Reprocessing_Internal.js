// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var RGLConstants = require("Reasongl/src/RGLConstants.js");
var Reasongl_web = require("Reasongl/src/web/reasongl_web.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Reprocessing_Common = require("./Reprocessing_Common.js");
var Reprocessing_Matrix = require("./Reprocessing_Matrix.js");
var Reprocessing_Shaders = require("./Reprocessing_Shaders.js");
var Reprocessing_Constants = require("./Reprocessing_Constants.js");

function getProgram(context, vertexShaderSource, fragmentShaderSource) {
  var vertexShader = Curry._2(Reasongl_web.Gl[/* createShader */8], context, RGLConstants.vertex_shader);
  Reasongl_web.Gl[/* shaderSource */11](context, vertexShader, vertexShaderSource);
  Curry._2(Reasongl_web.Gl[/* compileShader */12], context, vertexShader);
  var compiledCorrectly = Reasongl_web.Gl[/* getShaderParameter */54](context, vertexShader, /* Compile_status */1) === 1;
  if (compiledCorrectly) {
    var fragmentShader = Curry._2(Reasongl_web.Gl[/* createShader */8], context, RGLConstants.fragment_shader);
    Reasongl_web.Gl[/* shaderSource */11](context, fragmentShader, fragmentShaderSource);
    Curry._2(Reasongl_web.Gl[/* compileShader */12], context, fragmentShader);
    var compiledCorrectly$1 = Reasongl_web.Gl[/* getShaderParameter */54](context, fragmentShader, /* Compile_status */1) === 1;
    if (compiledCorrectly$1) {
      var program = Curry._1(Reasongl_web.Gl[/* createProgram */7], context);
      Curry._3(Reasongl_web.Gl[/* attachShader */9], context, program, vertexShader);
      Curry._2(Reasongl_web.Gl[/* deleteShader */10], context, vertexShader);
      Curry._3(Reasongl_web.Gl[/* attachShader */9], context, program, fragmentShader);
      Curry._2(Reasongl_web.Gl[/* deleteShader */10], context, fragmentShader);
      Curry._2(Reasongl_web.Gl[/* linkProgram */13], context, program);
      var linkedCorrectly = Reasongl_web.Gl[/* getProgramParameter */53](context, program, /* Link_status */1) === 1;
      if (linkedCorrectly) {
        return /* Some */[program];
      } else {
        console.log("Linking error: " + Curry._2(Reasongl_web.Gl[/* getProgramInfoLog */56], context, program));
        return /* None */0;
      }
    } else {
      console.log("Fragment shader error: " + Curry._2(Reasongl_web.Gl[/* getShaderInfoLog */55], context, fragmentShader));
      return /* None */0;
    }
  } else {
    console.log("Vertex shader error: " + Curry._2(Reasongl_web.Gl[/* getShaderInfoLog */55], context, vertexShader));
    return /* None */0;
  }
}

function createCanvas($$window, height, width) {
  Curry._3(Reasongl_web.Gl[/* Window */2][/* setWindowSize */6], $$window, width, height);
  var context = Curry._1(Reasongl_web.Gl[/* Window */2][/* getContext */7], $$window);
  Curry._5(Reasongl_web.Gl[/* viewport */44], context, -1, -1, width, height);
  Curry._5(Reasongl_web.Gl[/* clearColor */6], context, 0, 0, 0, 1);
  Curry._2(Reasongl_web.Gl[/* clear */45], context, RGLConstants.color_buffer_bit | RGLConstants.depth_buffer_bit);
  var camera = /* record */[/* projectionMatrix */Curry._1(Reasongl_web.Gl[/* Mat4 */51][/* create */1], /* () */0)];
  var vertexBuffer = Curry._1(Reasongl_web.Gl[/* createBuffer */15], context);
  var elementBuffer = Curry._1(Reasongl_web.Gl[/* createBuffer */15], context);
  var match = getProgram(context, Reprocessing_Shaders.vertexShaderSource, Reprocessing_Shaders.fragmentShaderSource);
  var program = match ? match[0] : Pervasives.failwith("Could not create the program and/or the shaders. Aborting.");
  Curry._2(Reasongl_web.Gl[/* useProgram */14], context, program);
  var aVertexPosition = Curry._3(Reasongl_web.Gl[/* getAttribLocation */47], context, program, "aVertexPosition");
  Curry._2(Reasongl_web.Gl[/* enableVertexAttribArray */48], context, aVertexPosition);
  var aVertexColor = Curry._3(Reasongl_web.Gl[/* getAttribLocation */47], context, program, "aVertexColor");
  Curry._2(Reasongl_web.Gl[/* enableVertexAttribArray */48], context, aVertexColor);
  var pMatrixUniform = Curry._3(Reasongl_web.Gl[/* getUniformLocation */46], context, program, "uPMatrix");
  Reasongl_web.Gl[/* uniformMatrix4fv */52](context, pMatrixUniform, camera[/* projectionMatrix */0]);
  var aTextureCoord = Curry._3(Reasongl_web.Gl[/* getAttribLocation */47], context, program, "aTextureCoord");
  Curry._2(Reasongl_web.Gl[/* enableVertexAttribArray */48], context, aTextureCoord);
  var texture = Curry._1(Reasongl_web.Gl[/* createTexture */17], context);
  Curry._2(Reasongl_web.Gl[/* activeTexture */18], context, RGLConstants.texture0);
  Curry._3(Reasongl_web.Gl[/* bindTexture */19], context, RGLConstants.texture_2d, texture);
  var uSampler = Curry._3(Reasongl_web.Gl[/* getUniformLocation */46], context, program, "uSampler");
  Reasongl_web.Gl[/* texImage2D_RGBA */41](context, RGLConstants.texture_2d, 0, 1, 1, 0, Curry._2(Reasongl_web.Gl[/* Bigarray */28][/* of_array */1], /* Uint8 */5, /* array */[
            255,
            255,
            255,
            255
          ]));
  Curry._4(Reasongl_web.Gl[/* texParameteri */20], context, RGLConstants.texture_2d, RGLConstants.texture_mag_filter, RGLConstants.linear);
  Curry._4(Reasongl_web.Gl[/* texParameteri */20], context, RGLConstants.texture_2d, RGLConstants.texture_min_filter, RGLConstants.linear_mipmap_nearest);
  Curry._2(Reasongl_web.Gl[/* enable */25], context, RGLConstants.blend);
  Curry._3(Reasongl_web.Gl[/* blendFunc */27], context, RGLConstants.src_alpha, RGLConstants.one_minus_src_alpha);
  Curry._7(Reasongl_web.Gl[/* Mat4 */51][/* ortho */6], camera[/* projectionMatrix */0], 0, width, height, 0, 0, 1);
  return /* record */[
          /* camera */camera,
          /* window */$$window,
          /* gl */context,
          /* vertexBuffer */vertexBuffer,
          /* elementBuffer */elementBuffer,
          /* aVertexColor */aVertexColor,
          /* aTextureCoord */aTextureCoord,
          /* aVertexPosition */aVertexPosition,
          /* pMatrixUniform */pMatrixUniform,
          /* uSampler */uSampler,
          /* batch : record */[
            /* vertexArray */Curry._2(Reasongl_web.Gl[/* Bigarray */28][/* create */0], /* Float32 */1, Caml_int32.imul(Reprocessing_Common.circularBufferSize, Reprocessing_Common.vertexSize)),
            /* elementArray */Curry._2(Reasongl_web.Gl[/* Bigarray */28][/* create */0], /* Uint16 */3, Reprocessing_Common.circularBufferSize),
            /* vertexPtr */0,
            /* elementPtr */0,
            /* currTex : None */0,
            /* nullTex */texture
          ],
          /* keyboard : record */[
            /* keyCode : Nothing */65,
            /* pressed */Reprocessing_Common.KeySet[/* empty */0],
            /* released */Reprocessing_Common.KeySet[/* empty */0],
            /* down */Reprocessing_Common.KeySet[/* empty */0]
          ],
          /* mouse : record */[
            /* pos : tuple */[
              0,
              0
            ],
            /* prevPos : tuple */[
              0,
              0
            ],
            /* pressed */false
          ],
          /* style : record */[
            /* strokeColor : None */0,
            /* strokeWeight */3,
            /* strokeCap : Round */0,
            /* fillColor : Some */[/* record */[
                /* r */0,
                /* g */0,
                /* b */0,
                /* a */1
              ]],
            /* tintColor : None */0,
            /* rectMode : Corner */0
          ],
          /* styleStack : [] */0,
          /* frame : record */[
            /* count */1,
            /* rate */10,
            /* deltaTime */0.001
          ],
          /* matrix */Reprocessing_Matrix.createIdentity(/* () */0),
          /* matrixStack : [] */0,
          /* size : record */[
            /* height */height,
            /* width */width,
            /* resizeable */true
          ]
        ];
}

function makeLocalBatch(env) {
  return /* record */[
          /* vertexArray */Curry._2(Reasongl_web.Gl[/* Bigarray */28][/* create */0], /* Float32 */1, Caml_int32.imul(Reprocessing_Common.circularBufferSize, Reprocessing_Common.vertexSize)),
          /* elementArray */Curry._2(Reasongl_web.Gl[/* Bigarray */28][/* create */0], /* Uint16 */3, Reprocessing_Common.circularBufferSize),
          /* vertexPtr */0,
          /* elementPtr */0,
          /* currTex : None */0,
          /* nullTex */env[/* batch */10][/* nullTex */5]
        ];
}

function drawGeometry(vertexArray, elementArray, mode, count, textureBuffer, env) {
  Curry._3(Reasongl_web.Gl[/* bindBuffer */16], env[/* gl */2], RGLConstants.array_buffer, env[/* vertexBuffer */3]);
  Curry._4(Reasongl_web.Gl[/* bufferData */43], env[/* gl */2], RGLConstants.array_buffer, vertexArray, RGLConstants.stream_draw);
  Reasongl_web.Gl[/* vertexAttribPointer */49](env[/* gl */2], env[/* aVertexPosition */7], 2, RGLConstants.float_, false, (Reprocessing_Common.vertexSize << 2), 0);
  Reasongl_web.Gl[/* vertexAttribPointer */49](env[/* gl */2], env[/* aVertexColor */5], 4, RGLConstants.float_, false, (Reprocessing_Common.vertexSize << 2), 8);
  Reasongl_web.Gl[/* vertexAttribPointer */49](env[/* gl */2], env[/* aTextureCoord */6], 2, RGLConstants.float_, false, (Reprocessing_Common.vertexSize << 2), 24);
  Curry._3(Reasongl_web.Gl[/* uniform1i */36], env[/* gl */2], env[/* uSampler */9], 0);
  Curry._3(Reasongl_web.Gl[/* bindBuffer */16], env[/* gl */2], RGLConstants.element_array_buffer, env[/* elementBuffer */4]);
  Curry._4(Reasongl_web.Gl[/* bufferData */43], env[/* gl */2], RGLConstants.element_array_buffer, elementArray, RGLConstants.stream_draw);
  Curry._3(Reasongl_web.Gl[/* bindTexture */19], env[/* gl */2], RGLConstants.texture_2d, textureBuffer);
  return Curry._5(Reasongl_web.Gl[/* drawElements */59], env[/* gl */2], mode, count, RGLConstants.unsigned_short, 0);
}

function flushGlobalBatch(env) {
  if (env[/* batch */10][/* elementPtr */3] > 0) {
    var match = env[/* batch */10][/* currTex */4];
    var textureBuffer = match ? match[0] : env[/* batch */10][/* nullTex */5];
    drawGeometry(Curry._3(Reasongl_web.Gl[/* Bigarray */28][/* sub */9], env[/* batch */10][/* vertexArray */0], 0, env[/* batch */10][/* vertexPtr */2]), Curry._3(Reasongl_web.Gl[/* Bigarray */28][/* sub */9], env[/* batch */10][/* elementArray */1], 0, env[/* batch */10][/* elementPtr */3]), RGLConstants.triangles, env[/* batch */10][/* elementPtr */3], textureBuffer, env);
    env[/* batch */10][/* currTex */4] = /* None */0;
    env[/* batch */10][/* vertexPtr */2] = 0;
    env[/* batch */10][/* elementPtr */3] = 0;
    return /* () */0;
  } else {
    return 0;
  }
}

function maybeFlushBatch(texture, el, vert, env) {
  if ((env[/* batch */10][/* elementPtr */3] + el | 0) >= Reprocessing_Common.circularBufferSize || (env[/* batch */10][/* vertexPtr */2] + vert | 0) >= Reprocessing_Common.circularBufferSize || env[/* batch */10][/* elementPtr */3] > 0 && env[/* batch */10][/* currTex */4] !== texture) {
    return flushGlobalBatch(env);
  } else {
    return 0;
  }
}

function addRectToGlobalBatch(env, param, param$1, param$2, param$3, param$4) {
  var a = param$4[/* a */3];
  var b = param$4[/* b */2];
  var g = param$4[/* g */1];
  var r = param$4[/* r */0];
  maybeFlushBatch(/* None */0, 6, 32, env);
  var set = Reasongl_web.Gl[/* Bigarray */28][/* set */7];
  var i = env[/* batch */10][/* vertexPtr */2];
  var vertexArrayToMutate = env[/* batch */10][/* vertexArray */0];
  Curry._3(set, vertexArrayToMutate, i + 0 | 0, param[0]);
  Curry._3(set, vertexArrayToMutate, i + 1 | 0, param[1]);
  Curry._3(set, vertexArrayToMutate, i + 2 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 3 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 4 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 5 | 0, a);
  Curry._3(set, vertexArrayToMutate, i + 6 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 7 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 8 | 0, param$1[0]);
  Curry._3(set, vertexArrayToMutate, i + 9 | 0, param$1[1]);
  Curry._3(set, vertexArrayToMutate, i + 10 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 11 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 12 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 13 | 0, a);
  Curry._3(set, vertexArrayToMutate, i + 14 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 15 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 16 | 0, param$2[0]);
  Curry._3(set, vertexArrayToMutate, i + 17 | 0, param$2[1]);
  Curry._3(set, vertexArrayToMutate, i + 18 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 19 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 20 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 21 | 0, a);
  Curry._3(set, vertexArrayToMutate, i + 22 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 23 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 24 | 0, param$3[0]);
  Curry._3(set, vertexArrayToMutate, i + 25 | 0, param$3[1]);
  Curry._3(set, vertexArrayToMutate, i + 26 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 27 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 28 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 29 | 0, a);
  Curry._3(set, vertexArrayToMutate, i + 30 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 31 | 0, 0.0);
  var ii = Caml_int32.div(i, Reprocessing_Common.vertexSize);
  var j = env[/* batch */10][/* elementPtr */3];
  var elementArrayToMutate = env[/* batch */10][/* elementArray */1];
  Curry._3(set, elementArrayToMutate, j + 0 | 0, ii);
  Curry._3(set, elementArrayToMutate, j + 1 | 0, ii + 1 | 0);
  Curry._3(set, elementArrayToMutate, j + 2 | 0, ii + 2 | 0);
  Curry._3(set, elementArrayToMutate, j + 3 | 0, ii + 1 | 0);
  Curry._3(set, elementArrayToMutate, j + 4 | 0, ii + 2 | 0);
  Curry._3(set, elementArrayToMutate, j + 5 | 0, ii + 3 | 0);
  env[/* batch */10][/* vertexPtr */2] = i + (Reprocessing_Common.vertexSize << 2) | 0;
  env[/* batch */10][/* elementPtr */3] = j + 6 | 0;
  return /* () */0;
}

function drawTriangle(env, param, param$1, param$2, param$3) {
  var a = param$3[/* a */3];
  var b = param$3[/* b */2];
  var g = param$3[/* g */1];
  var r = param$3[/* r */0];
  maybeFlushBatch(/* None */0, 24, 3, env);
  var set = Reasongl_web.Gl[/* Bigarray */28][/* set */7];
  var i = env[/* batch */10][/* vertexPtr */2];
  var vertexArrayToMutate = env[/* batch */10][/* vertexArray */0];
  Curry._3(set, vertexArrayToMutate, i + 0 | 0, param[0]);
  Curry._3(set, vertexArrayToMutate, i + 1 | 0, param[1]);
  Curry._3(set, vertexArrayToMutate, i + 2 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 3 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 4 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 5 | 0, a);
  Curry._3(set, vertexArrayToMutate, i + 6 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 7 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 8 | 0, param$1[0]);
  Curry._3(set, vertexArrayToMutate, i + 9 | 0, param$1[1]);
  Curry._3(set, vertexArrayToMutate, i + 10 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 11 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 12 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 13 | 0, a);
  Curry._3(set, vertexArrayToMutate, i + 14 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 15 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 16 | 0, param$2[0]);
  Curry._3(set, vertexArrayToMutate, i + 17 | 0, param$2[1]);
  Curry._3(set, vertexArrayToMutate, i + 18 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 19 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 20 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 21 | 0, a);
  Curry._3(set, vertexArrayToMutate, i + 22 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 23 | 0, 0.0);
  var ii = Caml_int32.div(i, Reprocessing_Common.vertexSize);
  var j = env[/* batch */10][/* elementPtr */3];
  var elementArrayToMutate = env[/* batch */10][/* elementArray */1];
  Curry._3(set, elementArrayToMutate, j + 0 | 0, ii);
  Curry._3(set, elementArrayToMutate, j + 1 | 0, ii + 1 | 0);
  Curry._3(set, elementArrayToMutate, j + 2 | 0, ii + 2 | 0);
  env[/* batch */10][/* vertexPtr */2] = i + Caml_int32.imul(3, Reprocessing_Common.vertexSize) | 0;
  env[/* batch */10][/* elementPtr */3] = j + 3 | 0;
  return /* () */0;
}

function drawLineWithMatrix(param, param$1, matrix, color, width, project, env) {
  var yy2 = param$1[1];
  var xx2 = param$1[0];
  var yy1 = param[1];
  var xx1 = param[0];
  var dx = xx2 - xx1;
  var dy = yy2 - yy1;
  var mag = Math.sqrt(dx * dx + dy * dy);
  var radius = width / 2;
  var xthing = dy / mag * radius;
  var ything = -dx / mag * radius;
  var match = project ? /* tuple */[
      dx / mag * radius,
      xthing
    ] : /* tuple */[
      0,
      0
    ];
  var projecty = match[1];
  var projectx = match[0];
  var x1 = xx2 + xthing + projectx;
  var y1 = yy2 + ything + projecty;
  var x2 = xx1 + xthing - projectx;
  var y2 = yy1 + ything - projecty;
  var x3 = xx2 - xthing + projectx;
  var y3 = yy2 - ything + projecty;
  var x4 = xx1 - xthing - projectx;
  var y4 = yy1 - ything - projecty;
  return addRectToGlobalBatch(env, Reprocessing_Matrix.matptmul(matrix, /* tuple */[
                  x1,
                  y1
                ]), Reprocessing_Matrix.matptmul(matrix, /* tuple */[
                  x2,
                  y2
                ]), Reprocessing_Matrix.matptmul(matrix, /* tuple */[
                  x3,
                  y3
                ]), Reprocessing_Matrix.matptmul(matrix, /* tuple */[
                  x4,
                  y4
                ]), color);
}

function drawArc(env, param, radx, rady, start, stop, isPie, matrix, param$1) {
  var a = param$1[/* a */3];
  var b = param$1[/* b */2];
  var g = param$1[/* g */1];
  var r = param$1[/* r */0];
  var yCenterOfCircle = param[1];
  var xCenterOfCircle = param[0];
  var noOfFans = ((radx + rady | 0) / 2 | 0) + 10 | 0;
  maybeFlushBatch(/* None */0, Caml_int32.imul(3, noOfFans), Caml_int32.imul(Reprocessing_Common.vertexSize, noOfFans + 3 | 0), env);
  var match = stop < start;
  var match$1 = match ? /* tuple */[
      stop,
      start
    ] : /* tuple */[
      start,
      stop
    ];
  var stop$1 = match$1[1];
  var start$1 = match$1[0];
  var pi = 4.0 * Math.atan(1.0);
  var anglePerFan = 2 * pi / noOfFans;
  var verticesData = env[/* batch */10][/* vertexArray */0];
  var elementData = env[/* batch */10][/* elementArray */1];
  var set = Reasongl_web.Gl[/* Bigarray */28][/* set */7];
  var get = Reasongl_web.Gl[/* Bigarray */28][/* get */5];
  var vertexArrayOffset = env[/* batch */10][/* vertexPtr */2];
  var elementArrayOffset = env[/* batch */10][/* elementPtr */3];
  var start_i = isPie ? (start$1 / anglePerFan | 0) - 3 | 0 : (start$1 / anglePerFan | 0) - 2 | 0;
  var stop_i = (stop$1 / anglePerFan | 0) + 1 | 0;
  for(var i = start_i; i <= stop_i; ++i){
    var param$2;
    if (isPie && (i - start_i | 0) === 0) {
      param$2 = /* tuple */[
        xCenterOfCircle,
        yCenterOfCircle
      ];
    } else {
      var angle = Caml_primitive.caml_float_max(Caml_primitive.caml_float_min(anglePerFan * (i + 1 | 0), stop$1), start$1);
      param$2 = /* tuple */[
        xCenterOfCircle + Math.cos(angle) * radx,
        yCenterOfCircle + Math.sin(angle) * rady
      ];
    }
    var match$2 = Reprocessing_Matrix.matptmul(matrix, param$2);
    var ii = Caml_int32.imul(i - start_i | 0, Reprocessing_Common.vertexSize) + vertexArrayOffset | 0;
    Curry._3(set, verticesData, ii + 0 | 0, match$2[0]);
    Curry._3(set, verticesData, ii + 1 | 0, match$2[1]);
    Curry._3(set, verticesData, ii + 2 | 0, r);
    Curry._3(set, verticesData, ii + 3 | 0, g);
    Curry._3(set, verticesData, ii + 4 | 0, b);
    Curry._3(set, verticesData, ii + 5 | 0, a);
    Curry._3(set, verticesData, ii + 6 | 0, 0.0);
    Curry._3(set, verticesData, ii + 7 | 0, 0.0);
    if ((i - start_i | 0) < 3) {
      Curry._3(set, elementData, (i - start_i | 0) + elementArrayOffset | 0, Caml_int32.div(ii, Reprocessing_Common.vertexSize));
    } else {
      var jj = (Caml_int32.imul((i - start_i | 0) - 3 | 0, 3) + elementArrayOffset | 0) + 3 | 0;
      Curry._3(set, elementData, jj, Caml_int32.div(vertexArrayOffset, Reprocessing_Common.vertexSize));
      Curry._3(set, elementData, jj + 1 | 0, Curry._2(get, elementData, jj - 1 | 0));
      Curry._3(set, elementData, jj + 2 | 0, Caml_int32.div(ii, Reprocessing_Common.vertexSize));
    }
  }
  env[/* batch */10][/* vertexPtr */2] = env[/* batch */10][/* vertexPtr */2] + Caml_int32.imul(noOfFans + 3 | 0, Reprocessing_Common.vertexSize) | 0;
  env[/* batch */10][/* elementPtr */3] = (env[/* batch */10][/* elementPtr */3] + Caml_int32.imul((stop_i - start_i | 0) - 3 | 0, 3) | 0) + 3 | 0;
  return /* () */0;
}

function drawEllipse(env, center, radx, rady, matrix, c) {
  return drawArc(env, center, radx, rady, 0, Reprocessing_Constants.tau, false, matrix, c);
}

function drawArcStroke(env, param, radx, rady, start, stop, isOpen, isPie, matrix, strokeColor, strokeWidth) {
  var a = strokeColor[/* a */3];
  var b = strokeColor[/* b */2];
  var g = strokeColor[/* g */1];
  var r = strokeColor[/* r */0];
  var yCenterOfCircle = param[1];
  var xCenterOfCircle = param[0];
  var verticesData = env[/* batch */10][/* vertexArray */0];
  var elementData = env[/* batch */10][/* elementArray */1];
  var noOfFans = ((radx + rady | 0) / 2 | 0) + 10 | 0;
  var set = Reasongl_web.Gl[/* Bigarray */28][/* set */7];
  maybeFlushBatch(/* None */0, Caml_int32.imul(noOfFans, 6), Caml_int32.imul((noOfFans << 1), Reprocessing_Common.vertexSize), env);
  var match = stop < start;
  var match$1 = match ? /* tuple */[
      stop,
      start
    ] : /* tuple */[
      start,
      stop
    ];
  var stop$1 = match$1[1];
  var start$1 = match$1[0];
  var pi = 4.0 * Math.atan(1.0);
  var anglePerFan = 2 * pi / noOfFans;
  var start_i = (start$1 / anglePerFan | 0) - 2 | 0;
  var stop_i = stop$1 / anglePerFan | 0;
  var prevEl = /* None */0;
  var strokeWidth$1 = strokeWidth;
  var halfStrokeWidth = strokeWidth$1 / 2;
  for(var i = start_i; i <= stop_i; ++i){
    var angle = Caml_primitive.caml_float_max(start$1, Caml_primitive.caml_float_min(anglePerFan * (i + 1 | 0), stop$1));
    var param_000 = xCenterOfCircle + Math.cos(angle) * (radx - halfStrokeWidth);
    var param_001 = yCenterOfCircle + Math.sin(angle) * (rady - halfStrokeWidth);
    var param$1 = /* tuple */[
      param_000,
      param_001
    ];
    var match$2 = Reprocessing_Matrix.matptmul(matrix, param$1);
    var param_000$1 = xCenterOfCircle + Math.cos(angle) * (radx + halfStrokeWidth);
    var param_001$1 = yCenterOfCircle + Math.sin(angle) * (rady + halfStrokeWidth);
    var param$2 = /* tuple */[
      param_000$1,
      param_001$1
    ];
    var match$3 = Reprocessing_Matrix.matptmul(matrix, param$2);
    var ii = env[/* batch */10][/* vertexPtr */2];
    Curry._3(set, verticesData, ii + 0 | 0, match$2[0]);
    Curry._3(set, verticesData, ii + 1 | 0, match$2[1]);
    Curry._3(set, verticesData, ii + 2 | 0, r);
    Curry._3(set, verticesData, ii + 3 | 0, g);
    Curry._3(set, verticesData, ii + 4 | 0, b);
    Curry._3(set, verticesData, ii + 5 | 0, a);
    Curry._3(set, verticesData, ii + 6 | 0, 0.0);
    Curry._3(set, verticesData, ii + 7 | 0, 0.0);
    var ii$1 = ii + Reprocessing_Common.vertexSize | 0;
    Curry._3(set, verticesData, ii$1 + 0 | 0, match$3[0]);
    Curry._3(set, verticesData, ii$1 + 1 | 0, match$3[1]);
    Curry._3(set, verticesData, ii$1 + 2 | 0, r);
    Curry._3(set, verticesData, ii$1 + 3 | 0, g);
    Curry._3(set, verticesData, ii$1 + 4 | 0, b);
    Curry._3(set, verticesData, ii$1 + 5 | 0, a);
    Curry._3(set, verticesData, ii$1 + 6 | 0, 0.0);
    Curry._3(set, verticesData, ii$1 + 7 | 0, 0.0);
    env[/* batch */10][/* vertexPtr */2] = env[/* batch */10][/* vertexPtr */2] + (Reprocessing_Common.vertexSize << 1) | 0;
    var currOuter = Caml_int32.div(ii$1, Reprocessing_Common.vertexSize);
    var currInner = Caml_int32.div(ii$1, Reprocessing_Common.vertexSize) - 1 | 0;
    var currEl = /* Some */[/* tuple */[
        currInner,
        currOuter
      ]];
    var match$4 = prevEl;
    if (match$4) {
      var match$5 = match$4[0];
      var prevInner = match$5[0];
      var elementArrayOffset = env[/* batch */10][/* elementPtr */3];
      Curry._3(set, elementData, elementArrayOffset, prevInner);
      Curry._3(set, elementData, elementArrayOffset + 1 | 0, match$5[1]);
      Curry._3(set, elementData, elementArrayOffset + 2 | 0, currOuter);
      Curry._3(set, elementData, elementArrayOffset + 3 | 0, currOuter);
      Curry._3(set, elementData, elementArrayOffset + 4 | 0, prevInner);
      Curry._3(set, elementData, elementArrayOffset + 5 | 0, currInner);
      env[/* batch */10][/* elementPtr */3] = env[/* batch */10][/* elementPtr */3] + 6 | 0;
      prevEl = currEl;
    } else {
      prevEl = currEl;
    }
  }
  if (isOpen) {
    return 0;
  } else {
    var startPt_000 = xCenterOfCircle + Math.cos(start$1) * radx;
    var startPt_001 = yCenterOfCircle + Math.sin(start$1) * rady;
    var startPt = /* tuple */[
      startPt_000,
      startPt_001
    ];
    var stopPt_000 = xCenterOfCircle + Math.cos(stop$1) * radx;
    var stopPt_001 = yCenterOfCircle + Math.sin(stop$1) * rady;
    var stopPt = /* tuple */[
      stopPt_000,
      stopPt_001
    ];
    var centerOfCircle = /* tuple */[
      xCenterOfCircle,
      yCenterOfCircle
    ];
    if (isPie) {
      drawLineWithMatrix(startPt, centerOfCircle, matrix, strokeColor, strokeWidth$1, false, env);
      drawLineWithMatrix(stopPt, centerOfCircle, matrix, strokeColor, strokeWidth$1, false, env);
      drawEllipse(env, centerOfCircle, halfStrokeWidth, halfStrokeWidth, matrix, strokeColor);
    } else {
      drawLineWithMatrix(startPt, stopPt, matrix, strokeColor, strokeWidth$1, false, env);
    }
    drawEllipse(env, startPt, halfStrokeWidth, halfStrokeWidth, matrix, strokeColor);
    return drawEllipse(env, stopPt, halfStrokeWidth, halfStrokeWidth, matrix, strokeColor);
  }
}

function loadImage(env, filename, isPixel) {
  var imageRef = /* record */[
    /* glData : None */0,
    /* drawnTo */false
  ];
  Reasongl_web.Gl[/* loadImage */33](filename, /* None */0, (function (imageData) {
          if (imageData) {
            var img = imageData[0];
            var context = env[/* gl */2];
            var texture = Curry._1(Reasongl_web.Gl[/* createTexture */17], context);
            var height = Curry._1(Reasongl_web.Gl[/* getImageHeight */32], img);
            var width = Curry._1(Reasongl_web.Gl[/* getImageWidth */31], img);
            var filter = isPixel ? RGLConstants.nearest : RGLConstants.linear;
            imageRef[/* glData */0] = /* Some */[/* record */[
                /* framebuffer : None */0,
                /* texture */texture,
                /* height */height,
                /* width */width
              ]];
            Curry._3(Reasongl_web.Gl[/* bindTexture */19], context, RGLConstants.texture_2d, texture);
            Reasongl_web.Gl[/* texImage2DWithImage */35](context, RGLConstants.texture_2d, 0, img);
            Curry._4(Reasongl_web.Gl[/* texParameteri */20], context, RGLConstants.texture_2d, RGLConstants.texture_mag_filter, filter);
            Curry._4(Reasongl_web.Gl[/* texParameteri */20], context, RGLConstants.texture_2d, RGLConstants.texture_min_filter, filter);
            Curry._4(Reasongl_web.Gl[/* texParameteri */20], context, RGLConstants.texture_2d, RGLConstants.texture_wrap_s, RGLConstants.clamp_to_edge);
            return Curry._4(Reasongl_web.Gl[/* texParameteri */20], context, RGLConstants.texture_2d, RGLConstants.texture_wrap_t, RGLConstants.clamp_to_edge);
          } else {
            return Pervasives.failwith("Could not load image '" + (filename + "'."));
          }
        }), /* () */0);
  return imageRef;
}

function loadImageFromMemory(env, data, isPixel) {
  var imageRef = /* record */[
    /* glData : None */0,
    /* drawnTo */false
  ];
  Reasongl_web.Gl[/* loadImageFromMemory */34](data, /* None */0, (function (imageData) {
          if (imageData) {
            var img = imageData[0];
            var texture = Curry._1(Reasongl_web.Gl[/* createTexture */17], env[/* gl */2]);
            var height = Curry._1(Reasongl_web.Gl[/* getImageHeight */32], img);
            var width = Curry._1(Reasongl_web.Gl[/* getImageWidth */31], img);
            var filter = isPixel ? RGLConstants.nearest : RGLConstants.linear;
            imageRef[/* glData */0] = /* Some */[/* record */[
                /* framebuffer : None */0,
                /* texture */texture,
                /* height */height,
                /* width */width
              ]];
            Curry._3(Reasongl_web.Gl[/* bindTexture */19], env[/* gl */2], RGLConstants.texture_2d, texture);
            Reasongl_web.Gl[/* texImage2DWithImage */35](env[/* gl */2], RGLConstants.texture_2d, 0, img);
            Curry._4(Reasongl_web.Gl[/* texParameteri */20], env[/* gl */2], RGLConstants.texture_2d, RGLConstants.texture_mag_filter, filter);
            Curry._4(Reasongl_web.Gl[/* texParameteri */20], env[/* gl */2], RGLConstants.texture_2d, RGLConstants.texture_min_filter, filter);
            Curry._4(Reasongl_web.Gl[/* texParameteri */20], env[/* gl */2], RGLConstants.texture_2d, RGLConstants.texture_wrap_s, RGLConstants.clamp_to_edge);
            return Curry._4(Reasongl_web.Gl[/* texParameteri */20], env[/* gl */2], RGLConstants.texture_2d, RGLConstants.texture_wrap_t, RGLConstants.clamp_to_edge);
          } else {
            return Pervasives.failwith("Could not load image");
          }
        }), /* () */0);
  return imageRef;
}

function drawImage(param, param$1, param$2, param$3, param$4, subx, suby, subw, subh, env) {
  var imgw = param[/* width */3];
  var imgh = param[/* height */2];
  var texture = param[/* texture */1];
  var match = env[/* style */13][/* tintColor */4];
  var match$1 = match ? match[0] : /* record */[
      /* r */1,
      /* g */1,
      /* b */1,
      /* a */1
    ];
  var a = match$1[/* a */3];
  var b = match$1[/* b */2];
  var g = match$1[/* g */1];
  var r = match$1[/* r */0];
  maybeFlushBatch(/* Some */[texture], 6, 32, env);
  var fsubx = subx / imgw;
  var fsuby = suby / imgh;
  var fsubw = subw / imgw;
  var fsubh = subh / imgh;
  var set = Reasongl_web.Gl[/* Bigarray */28][/* set */7];
  var ii = env[/* batch */10][/* vertexPtr */2];
  var vertexArray = env[/* batch */10][/* vertexArray */0];
  Curry._3(set, vertexArray, ii + 0 | 0, param$1[0]);
  Curry._3(set, vertexArray, ii + 1 | 0, param$1[1]);
  Curry._3(set, vertexArray, ii + 2 | 0, r);
  Curry._3(set, vertexArray, ii + 3 | 0, g);
  Curry._3(set, vertexArray, ii + 4 | 0, b);
  Curry._3(set, vertexArray, ii + 5 | 0, a);
  Curry._3(set, vertexArray, ii + 6 | 0, fsubx + fsubw);
  Curry._3(set, vertexArray, ii + 7 | 0, fsuby + fsubh);
  Curry._3(set, vertexArray, ii + 8 | 0, param$2[0]);
  Curry._3(set, vertexArray, ii + 9 | 0, param$2[1]);
  Curry._3(set, vertexArray, ii + 10 | 0, r);
  Curry._3(set, vertexArray, ii + 11 | 0, g);
  Curry._3(set, vertexArray, ii + 12 | 0, b);
  Curry._3(set, vertexArray, ii + 13 | 0, a);
  Curry._3(set, vertexArray, ii + 14 | 0, fsubx);
  Curry._3(set, vertexArray, ii + 15 | 0, fsuby + fsubh);
  Curry._3(set, vertexArray, ii + 16 | 0, param$3[0]);
  Curry._3(set, vertexArray, ii + 17 | 0, param$3[1]);
  Curry._3(set, vertexArray, ii + 18 | 0, r);
  Curry._3(set, vertexArray, ii + 19 | 0, g);
  Curry._3(set, vertexArray, ii + 20 | 0, b);
  Curry._3(set, vertexArray, ii + 21 | 0, a);
  Curry._3(set, vertexArray, ii + 22 | 0, fsubx + fsubw);
  Curry._3(set, vertexArray, ii + 23 | 0, fsuby);
  Curry._3(set, vertexArray, ii + 24 | 0, param$4[0]);
  Curry._3(set, vertexArray, ii + 25 | 0, param$4[1]);
  Curry._3(set, vertexArray, ii + 26 | 0, r);
  Curry._3(set, vertexArray, ii + 27 | 0, g);
  Curry._3(set, vertexArray, ii + 28 | 0, b);
  Curry._3(set, vertexArray, ii + 29 | 0, a);
  Curry._3(set, vertexArray, ii + 30 | 0, fsubx);
  Curry._3(set, vertexArray, ii + 31 | 0, fsuby);
  var jj = env[/* batch */10][/* elementPtr */3];
  var elementArray = env[/* batch */10][/* elementArray */1];
  Curry._3(set, elementArray, jj, Caml_int32.div(ii, Reprocessing_Common.vertexSize));
  Curry._3(set, elementArray, jj + 1 | 0, Caml_int32.div(ii, Reprocessing_Common.vertexSize) + 1 | 0);
  Curry._3(set, elementArray, jj + 2 | 0, Caml_int32.div(ii, Reprocessing_Common.vertexSize) + 2 | 0);
  Curry._3(set, elementArray, jj + 3 | 0, Caml_int32.div(ii, Reprocessing_Common.vertexSize) + 1 | 0);
  Curry._3(set, elementArray, jj + 4 | 0, Caml_int32.div(ii, Reprocessing_Common.vertexSize) + 2 | 0);
  Curry._3(set, elementArray, jj + 5 | 0, Caml_int32.div(ii, Reprocessing_Common.vertexSize) + 3 | 0);
  env[/* batch */10][/* vertexPtr */2] = ii + (Reprocessing_Common.vertexSize << 2) | 0;
  env[/* batch */10][/* elementPtr */3] = jj + 6 | 0;
  env[/* batch */10][/* currTex */4] = /* Some */[texture];
  return /* () */0;
}

function drawImageWithMatrix(image, x, y, width, height, subx, suby, subw, subh, env) {
  var partial_arg = env[/* matrix */16];
  var transform = function (param) {
    return Reprocessing_Matrix.matptmul(partial_arg, param);
  };
  var p1 = Curry._1(transform, /* tuple */[
        x + width | 0,
        y + height | 0
      ]);
  var p2 = Curry._1(transform, /* tuple */[
        x,
        y + height | 0
      ]);
  var p3 = Curry._1(transform, /* tuple */[
        x + width | 0,
        y
      ]);
  var p4 = Curry._1(transform, /* tuple */[
        x,
        y
      ]);
  return drawImage(image, p1, p2, p3, p4, subx, suby, subw, subh, env);
}

function drawImageWithMatrixf(image, x, y, width, height, subx, suby, subw, subh, env) {
  var partial_arg = env[/* matrix */16];
  var transform = function (param) {
    return Reprocessing_Matrix.matptmul(partial_arg, param);
  };
  var p1 = Curry._1(transform, /* tuple */[
        x + width,
        y + height
      ]);
  var p2 = Curry._1(transform, /* tuple */[
        x,
        y + height
      ]);
  var p3 = Curry._1(transform, /* tuple */[
        x + width,
        y
      ]);
  var p4 = Curry._1(transform, /* tuple */[
        x,
        y
      ]);
  return drawImage(image, p1, p2, p3, p4, subx, suby, subw, subh, env);
}

function resetSize(env, width, height) {
  env[/* size */18][/* width */1] = width;
  env[/* size */18][/* height */0] = height;
  var pixelWidth = Curry._1(Reasongl_web.Gl[/* Window */2][/* getPixelWidth */2], env[/* window */1]);
  var pixelHeight = Curry._1(Reasongl_web.Gl[/* Window */2][/* getPixelHeight */3], env[/* window */1]);
  Curry._5(Reasongl_web.Gl[/* viewport */44], env[/* gl */2], 0, 0, pixelWidth, pixelHeight);
  Curry._5(Reasongl_web.Gl[/* clearColor */6], env[/* gl */2], 0, 0, 0, 1);
  Curry._7(Reasongl_web.Gl[/* Mat4 */51][/* ortho */6], env[/* camera */0][/* projectionMatrix */0], 0, width, height, 0, 0, 1);
  return Reasongl_web.Gl[/* uniformMatrix4fv */52](env[/* gl */2], env[/* pMatrixUniform */8], env[/* camera */0][/* projectionMatrix */0]);
}

function createImage(width, height, env) {
  var context = env[/* gl */2];
  var texture = Curry._1(Reasongl_web.Gl[/* createTexture */17], context);
  var filter = RGLConstants.nearest;
  Curry._3(Reasongl_web.Gl[/* bindTexture */19], context, RGLConstants.texture_2d, texture);
  Curry._5(Reasongl_web.Gl[/* texImage2D_null */42], context, RGLConstants.texture_2d, 0, width, height);
  Curry._4(Reasongl_web.Gl[/* texParameteri */20], context, RGLConstants.texture_2d, RGLConstants.texture_mag_filter, filter);
  Curry._4(Reasongl_web.Gl[/* texParameteri */20], context, RGLConstants.texture_2d, RGLConstants.texture_min_filter, filter);
  Curry._4(Reasongl_web.Gl[/* texParameteri */20], context, RGLConstants.texture_2d, RGLConstants.texture_wrap_s, RGLConstants.clamp_to_edge);
  Curry._4(Reasongl_web.Gl[/* texParameteri */20], context, RGLConstants.texture_2d, RGLConstants.texture_wrap_t, RGLConstants.clamp_to_edge);
  var framebuffer = Curry._1(Reasongl_web.Gl[/* createFramebuffer */21], context);
  Curry._3(Reasongl_web.Gl[/* bindFramebuffer */22], context, RGLConstants.framebuffer, framebuffer);
  Curry._5(Reasongl_web.Gl[/* framebufferTexture2D */24], context, RGLConstants.framebuffer, RGLConstants.color_attachment0, RGLConstants.texture_2d, texture);
  Curry._2(Reasongl_web.Gl[/* bindDefaultFramebuffer */23], context, RGLConstants.framebuffer);
  return /* record */[
          /* glData : Some */[/* record */[
              /* framebuffer : Some */[framebuffer],
              /* texture */texture,
              /* height */height,
              /* width */width
            ]],
          /* drawnTo */false
        ];
}

function drawOnImage(image, env, cb) {
  var match = image[/* glData */0];
  if (match) {
    var glData = match[0];
    var context = env[/* gl */2];
    var match$1 = glData[/* framebuffer */0];
    var framebuffer;
    if (match$1) {
      framebuffer = match$1[0];
    } else {
      Curry._3(Reasongl_web.Gl[/* bindTexture */19], context, RGLConstants.texture_2d, glData[/* texture */1]);
      var framebuffer$1 = Curry._1(Reasongl_web.Gl[/* createFramebuffer */21], context);
      Curry._3(Reasongl_web.Gl[/* bindFramebuffer */22], context, RGLConstants.framebuffer, framebuffer$1);
      Curry._5(Reasongl_web.Gl[/* framebufferTexture2D */24], context, RGLConstants.framebuffer, RGLConstants.color_attachment0, RGLConstants.texture_2d, glData[/* texture */1]);
      framebuffer = framebuffer$1;
    }
    Curry._3(Reasongl_web.Gl[/* bindFramebuffer */22], context, RGLConstants.framebuffer, framebuffer);
    var init = env[/* style */13];
    var init$1 = env[/* size */18];
    var newEnv = /* record */[
      /* camera : record */[/* projectionMatrix */Curry._1(Reasongl_web.Gl[/* Mat4 */51][/* create */1], /* () */0)],
      /* window */env[/* window */1],
      /* gl */env[/* gl */2],
      /* vertexBuffer */env[/* vertexBuffer */3],
      /* elementBuffer */env[/* elementBuffer */4],
      /* aVertexColor */env[/* aVertexColor */5],
      /* aTextureCoord */env[/* aTextureCoord */6],
      /* aVertexPosition */env[/* aVertexPosition */7],
      /* pMatrixUniform */env[/* pMatrixUniform */8],
      /* uSampler */env[/* uSampler */9],
      /* batch */makeLocalBatch(env),
      /* keyboard */env[/* keyboard */11],
      /* mouse */env[/* mouse */12],
      /* style : record */[
        /* strokeColor */init[/* strokeColor */0],
        /* strokeWeight */env[/* style */13][/* strokeWeight */1],
        /* strokeCap */init[/* strokeCap */2],
        /* fillColor */init[/* fillColor */3],
        /* tintColor */init[/* tintColor */4],
        /* rectMode */init[/* rectMode */5]
      ],
      /* styleStack */List.map((function (s) {
              return /* record */[
                      /* strokeColor */s[/* strokeColor */0],
                      /* strokeWeight */s[/* strokeWeight */1],
                      /* strokeCap */s[/* strokeCap */2],
                      /* fillColor */s[/* fillColor */3],
                      /* tintColor */s[/* tintColor */4],
                      /* rectMode */s[/* rectMode */5]
                    ];
            }), env[/* styleStack */14]),
      /* frame */env[/* frame */15],
      /* matrix */Reprocessing_Matrix.createIdentity(/* () */0),
      /* matrixStack */List.map((function (m) {
              var mm = Reprocessing_Matrix.createIdentity(/* () */0);
              Reprocessing_Matrix.copyInto(m, mm);
              return mm;
            }), env[/* matrixStack */17]),
      /* size : record */[
        /* height */glData[/* height */2],
        /* width */glData[/* width */3],
        /* resizeable */init$1[/* resizeable */2]
      ]
    ];
    Reprocessing_Matrix.copyInto(env[/* matrix */16], newEnv[/* matrix */16]);
    Curry._5(Reasongl_web.Gl[/* viewport */44], context, 0, 0, glData[/* width */3], glData[/* height */2]);
    Curry._7(Reasongl_web.Gl[/* Mat4 */51][/* ortho */6], newEnv[/* camera */0][/* projectionMatrix */0], 0, glData[/* width */3], 0, glData[/* height */2], 0, 1);
    Reasongl_web.Gl[/* uniformMatrix4fv */52](newEnv[/* gl */2], newEnv[/* pMatrixUniform */8], newEnv[/* camera */0][/* projectionMatrix */0]);
    Curry._5(Reasongl_web.Gl[/* clearColor */6], context, 0, 0, 0, 0);
    Curry._1(cb, newEnv);
    flushGlobalBatch(newEnv);
    image[/* drawnTo */1] = true;
    Curry._5(Reasongl_web.Gl[/* clearColor */6], context, 0, 0, 0, 1);
    Curry._2(Reasongl_web.Gl[/* bindDefaultFramebuffer */23], context, RGLConstants.framebuffer);
    var pixelWidth = Curry._1(Reasongl_web.Gl[/* Window */2][/* getPixelWidth */2], env[/* window */1]);
    var pixelHeight = Curry._1(Reasongl_web.Gl[/* Window */2][/* getPixelHeight */3], env[/* window */1]);
    Curry._5(Reasongl_web.Gl[/* viewport */44], context, 0, 0, pixelWidth, pixelHeight);
    return Reasongl_web.Gl[/* uniformMatrix4fv */52](context, env[/* pMatrixUniform */8], env[/* camera */0][/* projectionMatrix */0]);
  } else {
    return /* () */0;
  }
}

function clearImage(image, env) {
  image[/* drawnTo */1] = false;
  var match = image[/* glData */0];
  if (match) {
    var match$1 = match[0][/* framebuffer */0];
    if (match$1) {
      Curry._3(Reasongl_web.Gl[/* bindFramebuffer */22], env[/* gl */2], RGLConstants.framebuffer, match$1[0]);
      Curry._2(Reasongl_web.Gl[/* clear */45], env[/* gl */2], RGLConstants.color_buffer_bit | RGLConstants.depth_buffer_bit);
      return Curry._2(Reasongl_web.Gl[/* bindDefaultFramebuffer */23], env[/* gl */2], RGLConstants.framebuffer);
    } else {
      return /* () */0;
    }
  } else {
    return /* () */0;
  }
}

var Matrix = 0;

exports.Matrix = Matrix;
exports.getProgram = getProgram;
exports.createCanvas = createCanvas;
exports.makeLocalBatch = makeLocalBatch;
exports.drawGeometry = drawGeometry;
exports.flushGlobalBatch = flushGlobalBatch;
exports.maybeFlushBatch = maybeFlushBatch;
exports.addRectToGlobalBatch = addRectToGlobalBatch;
exports.drawTriangle = drawTriangle;
exports.drawLineWithMatrix = drawLineWithMatrix;
exports.drawArc = drawArc;
exports.drawEllipse = drawEllipse;
exports.drawArcStroke = drawArcStroke;
exports.loadImage = loadImage;
exports.loadImageFromMemory = loadImageFromMemory;
exports.drawImage = drawImage;
exports.drawImageWithMatrix = drawImageWithMatrix;
exports.drawImageWithMatrixf = drawImageWithMatrixf;
exports.resetSize = resetSize;
exports.createImage = createImage;
exports.drawOnImage = drawOnImage;
exports.clearImage = clearImage;
/* Reasongl_web Not a pure module */
